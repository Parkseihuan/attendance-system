// Google Apps Script 코드 - 출석 체크 시스템 (완전 통합 버전)

// 스프레드시트 ID (Google Sheets URL에서 확인 가능)
const SPREADSHEET_ID = 'YOUR_SPREADSHEET_ID_HERE';

// 시트 이름
const SHEET_NAME = '출석체크';

function doPost(e) {
  console.log('doPost 호출됨');
  console.log('요청 데이터:', e);
  
  try {
    let data;
    
    // POST 요청 데이터 파싱
    if (e.postData && e.postData.contents) {
      console.log('POST 데이터 원본:', e.postData.contents);
      data = JSON.parse(e.postData.contents);
      console.log('파싱된 데이터:', data);
    } else {
      throw new Error('POST 데이터가 없습니다.');
    }
    
    // 관리자 기능 처리
    if (data.action) {
      return handleAdminActionPost(data);
    }
    
    // 향상된 저장 함수 사용
    console.log('향상된 스프레드시트 저장 시작...');
    const result = saveToSpreadsheetEnhanced(data);
    console.log('저장 결과:', result);
    
    // JSON 응답 반환
    const response = {
      success: true,
      message: '출석체크가 완료되었습니다.',
      data: result,
      method: 'POST',
      timestamp: new Date().toISOString()
    };
    
    console.log('응답 데이터:', response);
    
    return ContentService
      .createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    console.error('doPost 오류:', error);
    console.error('오류 스택:', error.stack);
    
    const errorResponse = {
      success: false,
      message: error.toString(),
      error: error.toString(),
      method: 'POST',
      timestamp: new Date().toISOString()
    };
    
    return ContentService
      .createTextOutput(JSON.stringify(errorResponse))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function doGet(e) {
  console.log('doGet 호출됨');
  console.log('GET 파라미터:', e.parameter);
  
  try {
    // 관리자 기능 처리
    if (e.parameter.action) {
      return handleAdminAction(e.parameter);
    }
    
    // JSONP 콜백 함수명 확인
    const callback = e.parameter.callback;
    
    if (callback && e.parameter.data) {
      console.log('JSONP 요청 처리 중...');
      console.log('콜백:', callback);
      console.log('데이터 원본:', e.parameter.data);
      
      // JSONP 요청 처리
      const data = JSON.parse(e.parameter.data);
      console.log('JSONP 파싱된 데이터:', data);
      
      // 향상된 저장 함수 사용
      const result = saveToSpreadsheetEnhanced(data);
      console.log('JSONP 저장 결과:', result);
      
      // JSONP 응답 생성
      const responseData = {
        success: true,
        message: '출석체크가 완료되었습니다.',
        data: result,
        method: 'JSONP'
      };
      
      const jsonpResponse = `${callback}(${JSON.stringify(responseData)});`;
      console.log('JSONP 응답:', jsonpResponse);
      
      return ContentService
        .createTextOutput(jsonpResponse)
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
        
    } else {
      console.log('일반 GET 요청 - 상태 확인');
      // 일반 GET 요청 - 상태 확인용
      return ContentService
        .createTextOutput(JSON.stringify({
          success: true,
          message: '출석체크 시스템이 정상 작동 중입니다.',
          timestamp: new Date().toISOString(),
          spreadsheetId: SPREADSHEET_ID ? '설정됨' : '미설정',
          method: 'GET'
        }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
  } catch (error) {
    console.error('doGet 오류:', error);
    console.error('오류 스택:', error.stack);
    
    if (e.parameter && e.parameter.callback) {
      // JSONP 에러 응답
      const errorResponse = `${e.parameter.callback}(${JSON.stringify({
        success: false,
        message: error.toString(),
        error: error.toString(),
        method: 'JSONP_ERROR'
      })});`;
      
      return ContentService
        .createTextOutput(errorResponse)
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
    }
    
    return ContentService
      .createTextOutput(JSON.stringify({
        success: false,
        message: error.toString(),
        error: error.toString(),
        method: 'GET_ERROR'
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// 향상된 저장 함수 (여러 방법으로 시도)
function saveToSpreadsheetEnhanced(data) {
  console.log('=== 향상된 저장 함수 시작 ===');
  console.log('받은 데이터:', JSON.stringify(data, null, 2));
  
  try {
    // 1단계: 기본 스프레드시트 ID 확인
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      console.warn('기본 스프레드시트 ID 미설정, 백업 방식으로 전환');
      return saveToBackupSpreadsheet(data);
    }
    
    console.log('SPREADSHEET_ID:', SPREADSHEET_ID);
    
    // 2단계: 스프레드시트 접근 시도
    let spreadsheet;
    try {
      spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
      console.log('기본 스프레드시트 열기 성공:', spreadsheet.getName());
    } catch (openError) {
      console.error('기본 스프레드시트 열기 실패:', openError);
      console.log('백업 방식으로 전환...');
      return saveToBackupSpreadsheet(data);
    }
    
    // 3단계: 시트 확인 및 생성
    let sheet = spreadsheet.getSheetByName(SHEET_NAME);
    if (!sheet) {
      console.log('시트가 없음, 새로 생성...');
      sheet = spreadsheet.insertSheet(SHEET_NAME);
      
      // 헤더 설정
      const headers = [
        '제출일시(KST)', '제출일시(ISO)', '이름', '소속', '이메일', '연락처', 
        '위치', '좌표', '기기ID', '브라우저정보', '제출시도', '전송방식'
      ];
      
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
      
      // 헤더 스타일
      const headerRange = sheet.getRange(1, 1, 1, headers.length);
      headerRange.setBackground('#4285f4');
      headerRange.setFontColor('white');
      headerRange.setFontWeight('bold');
      headerRange.setHorizontalAlignment('center');
      
      SpreadsheetApp.flush();
      console.log('헤더 설정 완료');
    }
    
    // 4단계: 현재 상태 확인
    const beforeLastRow = sheet.getLastRow();
    console.log('저장 전 마지막 행:', beforeLastRow);
    
    // 5단계: 데이터 준비
    const now = new Date();
    const kstTime = Utilities.formatDate(now, 'Asia/Seoul', 'yyyy-MM-dd HH:mm:ss');
    
    const row = [
      data.timestampKor || kstTime,
      data.timestamp || now.toISOString(),
      data.name || '',
      data.affiliation || '',
      data.email || '',
      data.phone || '',
      data.location || '',
      data.coordinates || '',
      data.deviceId || '',
      data.userAgent || '',
      data.submissionAttempt || 1,
      data.method || 'Enhanced'
    ];
    
    console.log('저장할 행 데이터:', row);
    
    // 6단계: 여러 방법으로 데이터 저장 시도
    try {
      // 방법 1: appendRow 사용
      sheet.appendRow(row);
      console.log('appendRow 완료');
    } catch (appendError) {
      console.warn('appendRow 실패, insertRowAfter 시도:', appendError);
      
      // 방법 2: insertRowAfter 사용
      const targetRow = beforeLastRow + 1;
      sheet.insertRowAfter(beforeLastRow);
      sheet.getRange(targetRow, 1, 1, row.length).setValues([row]);
      console.log('insertRowAfter 완료');
    }
    
    // 7단계: 강제 저장 및 새로고침
    SpreadsheetApp.flush();
    console.log('첫 번째 flush 완료');
    
    Utilities.sleep(500); // 0.5초 대기
    
    // 추가 강제 저장
    sheet.getRange('A1').setValue(sheet.getRange('A1').getValue());
    SpreadsheetApp.flush();
    console.log('두 번째 flush 완료');
    
    // 8단계: 저장 결과 확인
    const afterLastRow = sheet.getLastRow();
    console.log('저장 후 마지막 행:', afterLastRow);
    
    if (afterLastRow <= beforeLastRow) {
      throw new Error(`데이터가 저장되지 않음. 저장 전: ${beforeLastRow}, 저장 후: ${afterLastRow}`);
    }
    
    // 9단계: 저장된 데이터 검증
    const savedData = sheet.getRange(afterLastRow, 1, 1, row.length).getValues()[0];
    console.log('저장된 데이터 검증:', savedData);
    
    // 10단계: 중복 체크
    let duplicateCount = 1;
    if (afterLastRow > 1) {
      const deviceIds = sheet.getRange(2, 9, afterLastRow - 1, 1).getValues();
      const duplicates = deviceIds.filter(id => id[0] === data.deviceId);
      duplicateCount = duplicates.length;
      
      if (duplicateCount > 1) {
        console.log(`중복 출석 감지: ${data.deviceId}, 총 ${duplicateCount}회`);
      }
    }
    
    const result = {
      success: true,
      rowNumber: afterLastRow,
      timestamp: now.toISOString(),
      kstTimestamp: kstTime,
      deviceId: data.deviceId,
      duplicateCount: duplicateCount,
      spreadsheetName: spreadsheet.getName(),
      spreadsheetUrl: spreadsheet.getUrl(),
      sheetName: sheet.getName(),
      savedData: savedData
    };
    
    console.log('=== 저장 성공 ===');
    console.log('최종 결과:', result);
    
    return result;
    
  } catch (error) {
    console.error('=== 향상된 저장 실패 ===');
    console.error('오류:', error);
    console.error('오류 스택:', error.stack);
    
    // 백업 저장 시도
    console.log('백업 저장 시도...');
    try {
      const backupResult = saveToBackupSpreadsheet(data);
      console.log('백업 저장 성공:', backupResult);
      return backupResult;
    } catch (backupError) {
      console.error('백업 저장도 실패:', backupError);
      throw new Error(`기본 저장 실패: ${error.message}, 백업 저장도 실패: ${backupError.message}`);
    }
  }
}

// 다른 스프레드시트에 백업 저장 함수
function saveToBackupSpreadsheet(data) {
  try {
    console.log('=== 백업 스프레드시트에 저장 시작 ===');
    
    // 새 스프레드시트 생성 (임시 백업용)
    const backupName = '출석체크_백업_' + Utilities.formatDate(new Date(), 'Asia/Seoul', 'yyyyMMdd_HHmmss');
    const backupSpreadsheet = SpreadsheetApp.create(backupName);
    const backupSheet = backupSpreadsheet.getActiveSheet();
    backupSheet.setName('출석데이터');
    
    console.log('백업 스프레드시트 생성:', backupSpreadsheet.getUrl());
    
    // 헤더 설정
    const headers = [
      '제출일시(KST)', '제출일시(ISO)', '이름', '소속', '이메일', '연락처', 
      '위치', '좌표', '기기ID', '브라우저정보', '제출시도', '전송방식'
    ];
    
    backupSheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    
    // 현재 시간
    const now = new Date();
    const kstTime = Utilities.formatDate(now, 'Asia/Seoul', 'yyyy-MM-dd HH:mm:ss');
    
    // 데이터 행 추가
    const row = [
      data.timestampKor || kstTime,
      data.timestamp || now.toISOString(),
      data.name || '',
      data.affiliation || '',
      data.email || '',
      data.phone || '',
      data.location || '',
      data.coordinates || '',
      data.deviceId || '',
      data.userAgent || '',
      data.submissionAttempt || 1,
      'BACKUP_SAVE'
    ];
    
    backupSheet.appendRow(row);
    SpreadsheetApp.flush();
    
    console.log('백업 저장 완료');
    console.log('백업 URL:', backupSpreadsheet.getUrl());
    
    return {
      success: true,
      backupUrl: backupSpreadsheet.getUrl(),
      backupId: backupSpreadsheet.getId(),
      rowData: row,
      message: '백업 스프레드시트에 저장됨'
    };
    
  } catch (error) {
    console.error('백업 저장 오류:', error);
    throw error;
  }
}

// 스프레드시트 강제 새로고침 및 동기화 함수
function forceRefreshSpreadsheet() {
  try {
    console.log('=== 강제 새로고침 시작 ===');
    
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      throw new Error('SPREADSHEET_ID를 먼저 설정해주세요!');
    }
    
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    console.log('스프레드시트 열기:', spreadsheet.getName());
    
    // 모든 시트 새로고침
    const sheets = spreadsheet.getSheets();
    console.log('전체 시트 수:', sheets.length);
    
    sheets.forEach(sheet => {
      console.log(`시트 "${sheet.getName()}" 새로고침 중...`);
      // 강제 계산 새로고침
      sheet.getRange("A1").setValue(sheet.getRange("A1").getValue());
    });
    
    // 스프레드시트 강제 저장
    SpreadsheetApp.flush();
    console.log('스프레드시트 플러시 완료');
    
    // 잠시 대기 후 다시 확인
    Utilities.sleep(1000);
    
    const targetSheet = spreadsheet.getSheetByName(SHEET_NAME);
    if (targetSheet) {
      const lastRow = targetSheet.getLastRow();
      const lastCol = targetSheet.getLastColumn();
      console.log(`대상 시트 "${SHEET_NAME}" 상태:`, {
        lastRow: lastRow,
        lastColumn: lastCol,
        hasData: lastRow > 0
      });
      
      if (lastRow > 0) {
        const recentData = targetSheet.getRange(Math.max(1, lastRow - 2), 1, Math.min(3, lastRow), lastCol).getValues();
        console.log('최근 데이터 (최대 3행):', recentData);
      }
    }
    
    return {
      success: true,
      message: '새로고침 완료',
      spreadsheetUrl: spreadsheet.getUrl(),
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('새로고침 오류:', error);
    throw error;
  }
}

// 스프레드시트 상태 확인 함수
function checkSpreadsheetStatus() {
  console.log('=== 스프레드시트 상태 확인 ===');
  console.log('SPREADSHEET_ID:', SPREADSHEET_ID);
  
  try {
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      console.error('SPREADSHEET_ID가 설정되지 않았습니다!');
      return { error: 'SPREADSHEET_ID 미설정' };
    }
    
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    console.log('스프레드시트 이름:', spreadsheet.getName());
    console.log('스프레드시트 URL:', spreadsheet.getUrl());
    
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    if (sheet) {
      console.log('시트 존재함:', SHEET_NAME);
      console.log('마지막 행:', sheet.getLastRow());
      console.log('마지막 열:', sheet.getLastColumn());
      
      if (sheet.getLastRow() > 0) {
        const data = sheet.getRange(1, 1, Math.min(sheet.getLastRow(), 5), sheet.getLastColumn()).getValues();
        console.log('시트 데이터 (최대 5행):', data);
      }
    } else {
      console.log('시트 없음:', SHEET_NAME);
    }
    
    return {
      success: true,
      spreadsheetName: spreadsheet.getName(),
      spreadsheetUrl: spreadsheet.getUrl(),
      sheetExists: !!sheet,
      lastRow: sheet ? sheet.getLastRow() : 0
    };
    
  } catch (error) {
    console.error('상태 확인 오류:', error);
    return { error: error.toString() };
  }
}

// 스프레드시트 초기화 함수
function initializeSpreadsheet() {
  console.log('=== 스프레드시트 초기화 시작 ===');
  
  try {
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      throw new Error('SPREADSHEET_ID를 먼저 설정해주세요!');
    }
    
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    console.log('스프레드시트 열기 성공:', spreadsheet.getName());
    
    let sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (sheet) {
      console.log('기존 시트 발견, 초기화 중...');
      sheet.clear();
    } else {
      console.log('새 시트 생성 중...');
      sheet = spreadsheet.insertSheet(SHEET_NAME);
    }
    
    // 헤더 설정
    const headers = [
      '제출일시(KST)', '제출일시(ISO)', '이름', '소속', '이메일', '연락처', 
      '위치', '좌표', '기기ID', '브라우저정보', '제출시도', '전송방식'
    ];
    
    console.log('헤더 설정 중...');
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    
    // 헤더 스타일
    const headerRange = sheet.getRange(1, 1, 1, headers.length);
    headerRange.setBackground('#4285f4');
    headerRange.setFontColor('white');
    headerRange.setFontWeight('bold');
    headerRange.setHorizontalAlignment('center');
    
    // 열 너비 자동 조정
    sheet.autoResizeColumns(1, headers.length);
    
    // 강제 저장
    SpreadsheetApp.flush();
    
    console.log('=== 스프레드시트 초기화 완료 ===');
    return { 
      success: true, 
      message: '초기화 완료',
      spreadsheetName: spreadsheet.getName(),
      spreadsheetUrl: spreadsheet.getUrl()
    };
    
  } catch (error) {
    console.error('=== 스프레드시트 초기화 오류 ===');
    console.error('오류:', error);
    throw error;
  }
}

// 향상된 테스트 함수
function testSaveDataEnhanced() {
  console.log('=== 향상된 테스트 시작 ===');
  
  const testData = {
    name: '향상된테스트_' + Date.now(),
    affiliation: '테스트기관',
    email: 'test@example.com',
    phone: '010-1234-5678',
    location: '테스트위치',
    coordinates: '37.5665,126.9780',
    deviceId: 'enhanced_test_' + Date.now(),
    timestamp: new Date().toISOString(),
    timestampKor: new Date().toLocaleString('ko-KR'),
    userAgent: 'Enhanced Test Browser',
    submissionAttempt: 1,
    method: 'ENHANCED_TEST'
  };
  
  console.log('테스트 데이터:', testData);
  
  try {
    const result = saveToSpreadsheetEnhanced(testData);
    console.log('=== 향상된 테스트 성공 ===');
    console.log('결과:', result);
    return result;
  } catch (error) {
    console.error('=== 향상된 테스트 실패 ===');
    console.error('오류:', error);
    throw error;
  }
}

// 강제 새로고침 후 테스트
function refreshAndTest() {
  console.log('=== 새로고침 후 테스트 시작 ===');
  
  try {
    // 1단계: 강제 새로고침
    console.log('1단계: 강제 새로고침...');
    const refreshResult = forceRefreshSpreadsheet();
    console.log('새로고침 결과:', refreshResult);
    
    // 2단계: 잠시 대기
    console.log('2단계: 대기 중 (2초)...');
    Utilities.sleep(2000);
    
    // 3단계: 향상된 테스트 실행
    console.log('3단계: 향상된 테스트 실행...');
    const testResult = testSaveDataEnhanced();
    console.log('테스트 결과:', testResult);
    
    // 4단계: 다시 새로고침하여 확인
    console.log('4단계: 결과 확인을 위한 새로고침...');
    Utilities.sleep(1000);
    const finalRefresh = forceRefreshSpreadsheet();
    console.log('최종 새로고침 결과:', finalRefresh);
    
    return {
      success: true,
      refreshResult: refreshResult,
      testResult: testResult,
      finalRefresh: finalRefresh
    };
    
  } catch (error) {
    console.error('=== 새로고침 후 테스트 실패 ===');
    console.error('오류:', error);
    throw error;
  }
}

// 완전 초기화 후 테스트
function fullResetAndTest() {
  console.log('=== 완전 초기화 후 테스트 시작 ===');
  
  try {
    // 1단계: 스프레드시트 완전 초기화
    console.log('1단계: 완전 초기화...');
    const initResult = initializeSpreadsheet();
    console.log('초기화 결과:', initResult);
    
    // 2단계: 강제 저장 및 대기
    console.log('2단계: 강제 저장 및 대기...');
    SpreadsheetApp.flush();
    Utilities.sleep(3000);
    
    // 3단계: 상태 확인
    console.log('3단계: 상태 확인...');
    const statusResult = checkSpreadsheetStatus();
    console.log('상태 확인 결과:', statusResult);
    
    // 4단계: 테스트 데이터 저장
    console.log('4단계: 테스트 데이터 저장...');
    const testResult = testSaveDataEnhanced();
    console.log('테스트 저장 결과:', testResult);
    
    // 5단계: 최종 확인
    console.log('5단계: 최종 확인...');
    Utilities.sleep(2000);
    const finalStatus = checkSpreadsheetStatus();
    console.log('최종 상태:', finalStatus);
    
    return {
      success: true,
      initResult: initResult,
      statusResult: statusResult,
      testResult: testResult,
      finalStatus: finalStatus
    };
    
  } catch (error) {
    console.error('=== 완전 초기화 후 테스트 실패 ===');
    console.error('오류:', error);
    throw error;
  }
}

// 백업 테스트 함수
function testBackupSave() {
  console.log('=== 백업 저장 테스트 시작 ===');
  
  const testData = {
    name: '백업테스트_' + Date.now(),
    affiliation: '백업테스트기관',
    email: 'backup@test.com',
    phone: '010-9999-9999',
    location: '백업테스트위치',
    coordinates: '37.5665,126.9780',
    deviceId: 'backup_test_' + Date.now(),
    timestamp: new Date().toISOString(),
    timestampKor: new Date().toLocaleString('ko-KR'),
    userAgent: 'Backup Test Browser',
    submissionAttempt: 1,
    method: 'BACKUP_TEST'
  };
  
  try {
    const result = saveToBackupSpreadsheet(testData);
    console.log('=== 백업 저장 테스트 성공 ===');
    console.log('백업 결과:', result);
    console.log('백업 스프레드시트 URL:', result.backupUrl);
    return result;
  } catch (error) {
    console.error('=== 백업 저장 테스트 실패 ===');
    console.error('오류:', error);
    throw error;
  }
}

// 관리자 기능 처리 (GET 요청) - 강화된 버전
function handleAdminAction(params) {
  console.log('=== 관리자 GET 액션 처리 ===');
  console.log('액션:', params.action);
  console.log('모든 파라미터:', params);
  
  try {
    let result;
    
    switch (params.action) {
      case 'getStats':
        console.log('통계 조회 요청');
        result = getAttendanceStats();
        break;
        
      case 'getSettings':
        console.log('설정 조회 요청');
        result = getSystemSettings();
        break;
        
      case 'exportData':
        console.log('데이터 내보내기 요청');
        result = exportAttendanceData();
        break;
        
      case 'clearAllData':
        console.log('모든 데이터 삭제 요청 (GET)');
        // 보안 확인
        if (!params.adminPassword || params.adminPassword.length < 6) {
          throw new Error('관리자 권한이 필요합니다.');
        }
        result = clearAllAttendanceData();
        break;
        
      case 'updateSettings':
        console.log('설정 업데이트 요청 (GET)');
        if (!params.adminPassword || params.adminPassword.length < 6) {
          throw new Error('관리자 권한이 필요합니다.');
        }
        // GET 방식으로 전달된 설정 파라미터 처리
        const settings = {
          eventTitle: params.eventTitle,
          eventDescription: params.eventDescription,
          manualInstruction: params.manualInstruction
        };
        result = updateSystemSettings(settings);
        break;
        
      case 'updatePassword':
        console.log('비밀번호 변경 알림');
        if (!params.adminPassword || params.adminPassword.length < 6) {
          throw new Error('관리자 권한이 필요합니다.');
        }
        result = {
          success: true,
          message: '비밀번호 변경 알림 수신됨',
          timestamp: new Date().toISOString()
        };
        break;
        
      case 'updateGPSRadius':
        console.log('GPS 반경 업데이트 요청');
        if (!params.adminPassword || params.adminPassword.length < 6) {
          throw new Error('관리자 권한이 필요합니다.');
        }
        const radius = parseInt(params.gpsRadius);
        if (isNaN(radius) || radius < 5 || radius > 100) {
          throw new Error('GPS 반경은 5-100미터 사이여야 합니다.');
        }
        result = updateGPSRadius(radius);
        break;
        
      case 'notifyReset':
        console.log('중복 방지 초기화 알림');
        if (!params.adminPassword || params.adminPassword.length < 6) {
          throw new Error('관리자 권한이 필요합니다.');
        }
        result = {
          success: true,
          message: '중복 방지 초기화 알림 수신됨',
          timestamp: new Date().toISOString()
        };
        break;
        
      default:
        throw new Error('알 수 없는 관리자 액션: ' + params.action);
    }
    
    console.log('액션 처리 결과:', result);
    
    // JSONP 콜백이 있으면 JSONP 응답, 없으면 JSON 응답
    if (params.callback) {
      console.log('JSONP 콜백 응답:', params.callback);
      const jsonpResponse = params.callback + '(' + JSON.stringify(result) + ');';
      return ContentService
        .createTextOutput(jsonpResponse)
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
    } else {
      console.log('일반 JSON 응답');
      return ContentService
        .createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
  } catch (error) {
    console.error('관리자 액션 처리 오류:', error);
    console.error('오류 스택:', error.stack);
    
    const errorResult = {
      success: false,
      message: error.toString(),
      error: error.toString(),
      action: params.action,
      timestamp: new Date().toISOString()
    };
    
    // JSONP 콜백이 있으면 JSONP 오류 응답
    if (params.callback) {
      const jsonpErrorResponse = params.callback + '(' + JSON.stringify(errorResult) + ');';
      return ContentService
        .createTextOutput(jsonpErrorResponse)
        .setMimeType(ContentService.MimeType.JAVASCRIPT);
    } else {
      return ContentService
        .createTextOutput(JSON.stringify(errorResult))
        .setMimeType(ContentService.MimeType.JSON);
    }
  }
}

// 관리자 기능 처리 (POST 요청)
function handleAdminActionPost(data) {
  console.log('관리자 POST 액션:', data.action);
  
  try {
    switch (data.action) {
      case 'clearAllData':
        // 간단한 보안 확인
        if (!data.adminPassword || data.adminPassword.length < 6) {
          throw new Error('관리자 권한이 필요합니다.');
        }
        
        const clearResult = clearAllAttendanceData();
        return ContentService
          .createTextOutput(JSON.stringify(clearResult))
          .setMimeType(ContentService.MimeType.JSON);
          
      case 'updateSettings':
        const updateResult = updateSystemSettings(data.settings);
        return ContentService
          .createTextOutput(JSON.stringify(updateResult))
          .setMimeType(ContentService.MimeType.JSON);
          
      default:
        throw new Error('알 수 없는 관리자 액션: ' + data.action);
    }
  } catch (error) {
    console.error('관리자 POST 액션 처리 오류:', error);
    return ContentService
      .createTextOutput(JSON.stringify({
        success: false,
        message: error.toString(),
        error: error.toString()
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// 출석 데이터 내보내기 - 강화된 버전
function exportAttendanceData() {
  try {
    console.log('=== 데이터 내보내기 시작 ===');
    
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      console.warn('SPREADSHEET_ID 미설정');
      throw new Error('스프레드시트 ID가 설정되지 않았습니다. Apps Script 코드에서 SPREADSHEET_ID를 확인해주세요.');
    }
    
    console.log('스프레드시트 ID:', SPREADSHEET_ID);
    
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const url = spreadsheet.getUrl();
    const name = spreadsheet.getName();
    
    console.log('스프레드시트 이름:', name);
    console.log('스프레드시트 URL:', url);
    
    // 데이터 존재 여부 확인
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    let dataInfo = '데이터 없음';
    
    if (sheet) {
      const lastRow = sheet.getLastRow();
      const lastCol = sheet.getLastColumn();
      dataInfo = `${lastRow - 1}행 × ${lastCol}열 (헤더 제외)`;
      console.log('데이터 정보:', dataInfo);
    } else {
      console.log('시트가 존재하지 않음:', SHEET_NAME);
    }
    
    const result = {
      success: true,
      spreadsheetUrl: url,
      spreadsheetId: SPREADSHEET_ID,
      spreadsheetName: name,
      sheetName: SHEET_NAME,
      dataInfo: dataInfo,
      exportTime: new Date().toISOString(),
      message: '데이터 내보내기 성공'
    };
    
    console.log('=== 데이터 내보내기 완료 ===');
    console.log('결과:', result);
    
    return result;
    
  } catch (error) {
    console.error('데이터 내보내기 오류:', error);
    console.error('오류 스택:', error.stack);
    
    // 상세한 오류 정보 반환
    const errorResult = {
      success: false,
      message: error.toString(),
      error: error.toString(),
      spreadsheetId: SPREADSHEET_ID || '미설정',
      sheetName: SHEET_NAME,
      exportTime: new Date().toISOString(),
      troubleshooting: [
        'SPREADSHEET_ID가 올바르게 설정되었는지 확인',
        '스프레드시트에 대한 읽기 권한이 있는지 확인',
        '스프레드시트가 삭제되지 않았는지 확인'
      ]
    };
    
    console.log('오류 결과:', errorResult);
    throw error;
  }
}

// 모든 출석 데이터 삭제
function clearAllAttendanceData() {
  try {
    console.log('=== 모든 데이터 삭제 시작 ===');
    
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      throw new Error('스프레드시트 ID가 설정되지 않았습니다.');
    }
    
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      console.log('삭제할 시트가 없습니다.');
      return { success: true, message: '삭제할 데이터가 없습니다.' };
    }
    
    const lastRow = sheet.getLastRow();
    console.log('삭제 전 마지막 행:', lastRow);
    
    if (lastRow > 1) {
      // 헤더(1행)를 제외한 모든 데이터 삭제
      sheet.deleteRows(2, lastRow - 1);
      console.log('데이터 행 삭제 완료');
    }
    
    // 강제 저장
    SpreadsheetApp.flush();
    
    const afterLastRow = sheet.getLastRow();
    console.log('삭제 후 마지막 행:', afterLastRow);
    
    console.log('=== 모든 데이터 삭제 완료 ===');
    
    return {
      success: true,
      message: '모든 출석 데이터가 삭제되었습니다.',
      deletedRows: lastRow - 1,
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('데이터 삭제 오류:', error);
    throw error;
  }
}

// 시스템 설정 업데이트
function updateSystemSettings(settings) {
  try {
    console.log('=== 시스템 설정 업데이트 ===');
    console.log('새 설정:', settings);
    
    // PropertiesService를 사용하여 설정 저장
    const properties = PropertiesService.getScriptProperties();
    
    if (settings.eventTitle) {
      properties.setProperty('eventTitle', settings.eventTitle);
    }
    
    if (settings.eventDescription) {
      properties.setProperty('eventDescription', settings.eventDescription);
    }
    
    if (settings.manualInstruction) {
      properties.setProperty('manualInstruction', settings.manualInstruction);
    }
    
    if (settings.locations) {
      properties.setProperty('allowedLocations', JSON.stringify(settings.locations));
    }
    
    console.log('설정 저장 완료');
    
    return {
      success: true,
      message: '시스템 설정이 업데이트되었습니다.',
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('설정 업데이트 오류:', error);
    throw error;
  }
}

// 시스템 설정 조회
function getSystemSettings() {
  try {
    const properties = PropertiesService.getScriptProperties();
    
    const settings = {
      eventTitle: properties.getProperty('eventTitle') || '🎓 세미나실 출석 체크',
      eventDescription: properties.getProperty('eventDescription') || '행사 참석 확인을 위해 정보를 입력해 주세요',
      manualInstruction: properties.getProperty('manualInstruction') || '행사장 앞쪽에 비치된 <strong>\'참석자 명부\'</strong>에 직접 기재해 주시기 바랍니다.',
      allowedLocations: JSON.parse(properties.getProperty('allowedLocations') || '[]')
    };
    
    // 기본 위치 설정이 없으면 기본값 설정
    if (settings.allowedLocations.length === 0) {
      settings.allowedLocations = [
        { name: '단호홀', lat: 37.228848, lng: 127.167855, radius: 30 },
        { name: '벽소홀', lat: 37.228767, lng: 127.167449, radius: 30 },
        { name: '대학교 본관', lat: 37.227239, lng: 127.166598, radius: 30 }
      ];
    }
    
    return {
      success: true,
      settings: settings,
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('설정 조회 오류:', error);
    throw error;
  }
}

// 통계 조회 함수 (강화된 버전)
function getAttendanceStats() {
  try {
    console.log('=== 통계 조회 시작 ===');
    
    if (!SPREADSHEET_ID || SPREADSHEET_ID === 'YOUR_SPREADSHEET_ID_HERE') {
      console.warn('SPREADSHEET_ID 미설정, 기본 통계 반환');
      return {
        success: true,
        totalAttendees: 0,
        uniqueDevices: 0,
        duplicates: 0,
        lastUpdate: new Date().toISOString(),
        message: 'SPREADSHEET_ID 미설정'
      };
    }
    
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      console.log('시트가 존재하지 않음');
      return {
        success: true,
        totalAttendees: 0,
        uniqueDevices: 0,
        duplicates: 0,
        lastUpdate: new Date().toISOString(),
        message: '데이터 시트 없음'
      };
    }
    
    const lastRow = sheet.getLastRow();
    console.log('마지막 행:', lastRow);
    
    if (lastRow <= 1) {
      console.log('데이터 없음 (헤더만 존재)');
      return {
        success: true,
        totalAttendees: 0,
        uniqueDevices: 0,
        duplicates: 0,
        lastUpdate: new Date().toISOString(),
        message: '출석 데이터 없음'
      };
    }
    
    // 모든 데이터 가져오기 (헤더 제외)
    const dataRange = sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn());
    const data = dataRange.getValues();
    console.log('데이터 행 수:', data.length);
    
    // 기기 ID는 9번째 열 (인덱스 8)
    const deviceIds = data.map(row => row[8]).filter(id => id && id.toString().trim() !== '');
    console.log('유효한 기기 ID 수:', deviceIds.length);
    
    // 고유 기기 수 계산
    const uniqueDeviceIds = [...new Set(deviceIds)];
    const uniqueDevices = uniqueDeviceIds.length;
    const totalAttendees = deviceIds.length;
    const duplicates = totalAttendees - uniqueDevices;
    
    console.log('통계 계산 완료:', {
      totalAttendees: totalAttendees,
      uniqueDevices: uniqueDevices,
      duplicates: duplicates
    });
    
    // 마지막 업데이트 시간 (가장 최근 데이터의 타임스탬프)
    let lastUpdate = new Date().toISOString();
    if (data.length > 0) {
      // 두 번째 열(인덱스 1)이 ISO 타임스탬프
      const timestamps = data.map(row => row[1]).filter(ts => ts);
      if (timestamps.length > 0) {
        const latestTimestamp = timestamps[timestamps.length - 1];
        if (latestTimestamp instanceof Date) {
          lastUpdate = latestTimestamp.toISOString();
        } else if (typeof latestTimestamp === 'string') {
          lastUpdate = latestTimestamp;
        }
      }
    }
    
    const result = {
      success: true,
      totalAttendees: totalAttendees,
      uniqueDevices: uniqueDevices,
      duplicates: duplicates,
      lastUpdate: lastUpdate,
      spreadsheetName: spreadsheet.getName(),
      dataRows: data.length,
      timestamp: new Date().toISOString()
    };
    
    console.log('=== 통계 조회 완료 ===');
    console.log('최종 결과:', result);
    
    return result;
    
  } catch (error) {
    console.error('통계 조회 오류:', error);
    console.error('오류 스택:', error.stack);
    
    // 오류 발생 시에도 기본 구조 반환
    return {
      success: false,
      totalAttendees: 0,
      uniqueDevices: 0,
      duplicates: 0,
      lastUpdate: new Date().toISOString(),
      error: error.toString(),
      message: '통계 조회 중 오류 발생'
    };
  }
}
